---
title: "R Notebook"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

if(!require('pacman')) {install.packages('pacman')}
pacman::p_load(openxlsx, dplyr, reshape2, stringr)

# BiocManager::install("GenomicRanges")
library(GenomicRanges)

source('libraryDesignFunctions.R')
```

# Input Parameters + Load Data
```{r}
# Import Relevant Datasets
wd <- getwd()
wd # verify directory location

snp_list <- unique(read.xlsx(paste0(wd,"//input//snp_loc_hg19.xlsx")))
rownames(snp_list) <- NULL
snp_list$chr <- as.character(snp_list$chr)


# Get refseq conversion for chromosome numbers. Needed for compatibility with CRISPick
refseqLookup <- read.delim(paste0(wd,"//input//seq_report_hg19.tsv"))
refseqLookup <- subset(refseqLookup, Role=="assembled-molecule")

# Rename columns for convenience
names(refseqLookup)[names(refseqLookup)=="Chromosome.name"] <- "chr"
names(refseqLookup)[names(refseqLookup)=="RefSeq.seq.accession"] <- "refseq"
refseqLookup <- refseqLookup %>%
  select(chr, refseq)
```

# Preprocess Input for CRISPick

## Combine Nearby SNP Regions

Will use 200bp regions for most SNPs. The 300 and 400bp regions are for any
200bp regions that don't have enough good quality guides.
```{r}
regions200 <- findSnpRegions(200, snp_list)
regions300 <- findSnpRegions(300, snp_list)
regions400 <- findSnpRegions(400, snp_list)

# any(is.na(g_overlap@to)) # << DEBUG: Check for lost SNPs. Should be FALSE
```

## Convert to CRISPick Input Format
```{r}
crispick200 <- formatCrispick(regions200, refseqLookup)
crispick300 <- formatCrispick(regions300, refseqLookup)
crispick400 <- formatCrispick(regions400, refseqLookup)

# Only need the 'crispick' column to run CRISPick for library design.
crispick200Input <- crispick200 %>% select(crispick)
crispick300Input <- crispick300 %>% select(crispick)
crispick400Input <- crispick400 %>% select(crispick)
```

## Export SNP Regions as regions and as CRISPick Input Format
```{r}
# Save SNP regions
write.xlsx(regions200, file = paste0(wd, "//preprocessed//regions200.xlsx"))
write.xlsx(regions300, file = paste0(wd, "//preprocessed//regions300.xlsx"))
write.xlsx(regions400, file = paste0(wd, "//preprocessed//regions400.xlsx"))

# Save CRISPick Inputs
write.table(crispick200Input, paste0(wd, "//preprocessed//loc200.fasta"), row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(crispick300Input, paste0(wd, "//preprocessed//loc300.fasta"), row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(crispick400Input, paste0(wd, "//preprocessed//loc400.fasta"), row.names=FALSE, col.names=FALSE, quote=FALSE)
```

PAUSE HERE >> run CRISPick using fasta file.

----------------------------------------------------------------------------

# Create Library from CRISPick Output
## Import CRISPick Output
```{r}
GDO200 <- read.xlsx(paste0(wd,"//crispick_output//sgrna_designs_200bp_i30.xlsx"))
GDO300 <- read.xlsx(paste0(wd,"//crispick_output//sgrna_designs_300bp_i30.xlsx"))
GDO400 <- read.xlsx(paste0(wd,"//crispick_output//sgrna_designs_400bp_i30.xlsx"))

keepCol <- c("Input", "Reference.Sequence", "Orientation", "sgRNA.'Cut'.Position", 
            "sgRNA.Sequence", "sgRNA.Context.Sequence", "On-Target.Efficacy.Score", "Pick.Order")

GDO200 <- select(GDO200, all_of(keepCol))
GDO300 <- select(GDO300, all_of(keepCol))
GDO400 <- select(GDO400, all_of(keepCol))

# Alternative column selection:
# guides <- guides %>%
#   subset(select = -c(Quota, Target.Taxon, Target.Gene.ID, Target.Gene.Symbol, Target.Alias, 
#                      CRISPR.Mechanism, Target.Domain, TSS.Position, PAM.Policy))

```

## GC + TTTT filter
Good GC content, no poly T, On-Target Efficacy > 0.2
Renumbers the rows after removing guides that don't meet the filter criteria.
```{r}
GDO200 <- filterGDO(GDO200)
GDO300 <- filterGDO(GDO300)
GDO400 <- filterGDO(GDO400)
```

## Add guide coordinates
```{r}
# Add GDO locations: chromosome number + start/end coordinates.
GDO200 <- addGDOLoc(GDO200, refseqLookup)
GDO300 <- addGDOLoc(GDO300, refseqLookup)
GDO400 <- addGDOLoc(GDO400, refseqLookup)

# Add the SNP Region
GDO200 <- left_join(GDO200, select(crispick200, SNP, crispick), join_by("Input"=="crispick"))
GDO300 <- left_join(GDO300, select(crispick300, SNP, crispick), join_by("Input"=="crispick"))
GDO400 <- left_join(GDO400, select(crispick400, SNP, crispick), join_by("Input"=="crispick"))

# Add rownumber for reference later
GDO200$n <- as.numeric(rownames(GDO200))
GDO300$n <- as.numeric(rownames(GDO300))
GDO400$n <- as.numeric(rownames(GDO400))

# Debug
# all(GDO200$start < GDO200$end) # CHECK that coordinate order is correct. TRUE if okay.
# all(guides$n == as.numeric(rownames(guides))) #CHECK that n == rownumber. TRUE if okay.

```

## Get top non-overlapping guides.

Get indices of overlapping guides.
```{r}
GDO200Overlap <- findSelfOverlap(GDO200, "chr", "start", "end")
GDO300Overlap <- findSelfOverlap(GDO300, "chr", "start", "end")
GDO400Overlap <- findSelfOverlap(GDO400, "chr", "start", "end")
```

Get top guides.
```{r}
# Pick the top performing guides for each SNP region width.
# Here we pick the top 3. Could pick top 5 etc.
numGDO <- 3

topGDO200 <- pickTopGDO(numGDO, GDO200, regions200, GDO200Overlap)
topGDO300 <- pickTopGDO(numGDO, GDO300, regions300, GDO300Overlap)
topGDO400 <- pickTopGDO(numGDO, GDO400, regions400, GDO400Overlap)
```

Export list of top guides.
```{r}
write.xlsx(topGDO200, file = paste0(wd, "//output//top3_200bp_i30.xlsx"))
write.xlsx(topGDO300, file = paste0(wd, "//output//top3_300bp_i30.xlsx"))
write.xlsx(topGDO400, file = paste0(wd, "//output//top3_400bp_i30.xlsx"))
```


# QC
How is the on-target score?
```{r}
print("Mean Number of Guides per SNP")
print(paste("GDO200:", mean(table(topGDO200$SNP))))
print(paste("GDO300:", mean(table(topGDO300$SNP))))
print(paste("GDO400:", mean(table(topGDO400$SNP))))

print("Mean On-Target Efficacy Score for the Library")
print(paste("GDO200:", mean(topGDO200$`On-Target.Efficacy.Score`)))
print(paste("GDO300:", mean(topGDO300$`On-Target.Efficacy.Score`)))
print(paste("GDO400:", mean(topGDO400$`On-Target.Efficacy.Score`)))

hist(table(topGDO200$SNP))
hist(table(topGDO300$SNP))
hist(table(topGDO400$SNP))

hist(topGDO200$`On-Target.Efficacy.Score`)
hist(topGDO300$`On-Target.Efficacy.Score`)
hist(topGDO400$`On-Target.Efficacy.Score`)

# On-Target Efficacy by SNP Region
# guide_summary <- top_guides %>%
#   group_by(SNP) %>%
#   summarise(mean = mean(`On-Target.Efficacy.Score`))
# 
# subset(guide_summary, mean < 0.2)
```
# Combining Guide Searches
First ran guide search for 200bp, ran QC. Then ran 300bp and 400bp to get more guides for poorly performing regions.

Load all GDOs + Regions if needed:
```{r}
wd <- getwd()

# Load all guide pools
GDO200 <- read.xlsx(paste0(wd,"//output//top3_200bp_i30.xlsx"))
GDO300 <- read.xlsx(paste0(wd,"//output//top3_300bp_i30.xlsx"))
GDO400 <- read.xlsx(paste0(wd,"//output//top3_400bp_i30.xlsx"))
# note, less guides in 300bp & 400bp because the regions were combined. There are fewer regions.

# Load regions by width
regions200 <- read.xlsx(paste0(wd,"//preprocessed//regions200.xlsx"))
regions300 <- read.xlsx(paste0(wd,"//preprocessed//regions300.xlsx"))
regions400 <- read.xlsx(paste0(wd,"//preprocessed//regions400.xlsx"))
```

Loading all guide searches:
```{r}
# Initialize final library
regions <- regions200
finalGDO <- GDO200
numGDO <- 3

# NOTE/TODO:
# The bad regions from our original pool (GDO200) are not part of any combined region
# i.e. where 2+ SNPs were combined in the same region.
# If the bad region names change from pool to pool,
# you will need to UPDATE replaceBadRegion() to throw out the UNCOMBINED regions
# before adding the combined region, to accommodate.

# Get any regions that are missing or do not have enough guides
badRegion <- getBadRegion(finalGDO, regions, numGDO) # 8 bad regions

if(nrow(badRegion)>0){
  finalGDO <- replaceBadRegion(finalGDO, GDO300, regions, badRegion)
}

badRegion <- getBadRegion(finalGDO, regions, numGDO) # 4 bad regions

if(nrow(badRegion)>0){
  finalGDO <- replaceBadRegion(finalGDO, GDO400, regions, badRegion)
}

badRegion <- getBadRegion(finalGDO, regions, numGDO) # no bad regions
```

Quality Control
```{r}
# Check that you have all the expected regions from the 200bp
  # i.e. you haven't LOST any regions and you haven't ADDED any regions by accident

all(finalGDO$SNP %in% regions$SNP)
!any(is.na(finalGDO$SNP))

# Check for no overlaps between GUIDES in the library
finalGDOOverlap <- findSelfOverlap(finalGDO, "chr","start","end",selfBool = TRUE)

# Check that each guide overlaps with only ONE REGION

reg200Overlap <- findOverlap(finalGDO, regions200,
                          "chr", "start", "end",
                          "chr", "start", "end")
# 212 out of 222 guides overlap the 200bp region

reg400Overlap <- findOverlap(finalGDO, regions400,
                          "chr", "start", "end",
                          "chr", "start", "end")
# All guides overlap a 400bp region.
```

Export guide list:
```{r}
write.xlsx(finalGDO, file = paste0(wd, "//output//finalTargetGDOi30.xlsx"))

# finalGDO <- read.xlsx(paste0(wd,"//output//finalTargetGDOi30.xlsx"))
```

# Updating Positive Controls
We submitted a list of interesting genes to CRISPick to design promoter targeting control guides.
Next, we want to:
1) Remove any designed guides that overlap with our validated guides.
2) Of the remaining pool, pick the best performing guides. (i.e. top 3 or top 5)

## Load Data
```{r}
wd <- getwd()

# Import new guide designs
posA30 <- read.xlsx(paste0(wd,"//crispick_output//sgrna_designs_promoter_a30.xlsx"))
names(posA30)[names(posA30)=="Target.Gene.Symbol"] <- "SNP"

# Get refseq conversion for chromosome numbers. Needed for compatibility with CRISPick
refseqLookup <- read.delim(paste0(wd,"//input//seq_report_hg19.tsv"))
refseqLookup <- subset(refseqLookup, Role=="assembled-molecule")

# Rename columns for convenience
names(refseqLookup)[names(refseqLookup)=="Chromosome.name"] <- "chr"
names(refseqLookup)[names(refseqLookup)=="RefSeq.seq.accession"] <- "refseq"
refseqLookup <- refseqLookup %>%
  select(chr, refseq)
```

```{r}
# Add chromosome number based on refseq lookup table
posA30 <- addGDOLoc(posA30, refseqLookup)

# Use Input as the "SNP" region
names(posA30)[names(posA30)=="Target.Gene.Symbol"] <- "SNP"

all(posA30$start < posA30$end) # CHECK that coordinate order is correct. TRUE if okay.

# Add rownumber for reference later
posA30$n <- as.numeric(rownames(posA30))


all(posA30$n == as.numeric(rownames(posA30))) #CHECK that n == rownumber. TRUE if okay.
```

```{r}
posGene <- read.table(paste0(wd,"//input//crispick_pos_ctrl.txt"))
colnames(posGene) <- "SNP"

validCtrl <- read.xlsx(paste0(wd, "//input//validated_pos_ctrl.xlsx"))
```

First remove any guides that overlap the validated guides.

```{r}
posOverlap <- findOverlap(validCtrl, posA30,
                          "chr", "start", "end",
                          "chr", "start", "end")
# 12 new guides overlap the validated guides

# Remove guides that overlap validated guides from the pool.
posPool <- posA30[!posA30$n %in% posOverlap[,2],]

```

Pick top 3 guides for each promoter region:
```{r}
# Get indices of guides that are overlapping.
posOverlap <- findSelfOverlap(posPool, "chr", "start", "end")

# Pick top guides for each promoter region.
topPos <- pickTopGDO(3, posA30, posGene, posOverlap)
```

Export the top guides. Go in order of pick order, fill in where we don't have validated guides.
Will combine the lists manually since there's not too many guides.
Need to manually pick+evaluate RPA1/SMYD4 guides since the region is overlapping..
```{r}
write.xlsx(topPos, file = paste0(wd, "//output//top3_promoter_a30.xlsx"))
```

